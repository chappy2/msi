
<section class="msi-slides" data-run-in-terminal="code/example1/src/index.coffee" data-run-in-terminal-bin="coffee" data-run-in-terminal-args=" --compile ">
    <h2>Compiler und Syntax</h2>
    <p> Argumente zum kompilieren: compile, watch </p>
<aside class="notes">
<ul>
<li> klassisches Hello World. Zum kompilieren coffee --compile.</li>
<li>-- watch für dev. Änderungen in einem dokuemnt sofort kompiliert.</li>
<li> was fällt auf? wenig klammern, einrückung, string interpolation </li>
</ul></aside>
    </section>


<section class="msi-slides" >
     <h2>Compiler und Syntax</h2>
     <h4>Ersetzungen von CoffeeScript</h4>
     <table class="comsyn">
        <thead>
            <tr>
                <th>JavaScript</th>
                <th>CoffeeScript</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>{}</td>
                <td>Einrückung</td>                
            </tr>
             <tr>
                <td>var</td>
                <td>Definition und Scope </!-- br>automatisiert</td>                
            </tr>
             <tr>
                <td>return</td>
                <td> Letzter Ausdruck</td>                
            </tr>
             <tr>
                <td>function</td>
                <td>-></td>                
            </tr>
             <tr>
                <td>this</td>
                <td> @</td>                
            </tr>
        </tbody>
     </table>
<aside class="notes">
<ul>
<li> Was macht der compiler anders? {} durch einrückung ersetzt. kein var und return. </li>
<li>Definition wird abgenommen und sicherheiten eingefügt (scoping). in javascript gibt es nur global und function scope</li>
<li>function als pfeil: viel boilerplate weg. es gibt sehr viele functionen in javascript</li>
<li>this als @</li>
</ul></aside>
</section>

<section class="msi-slides" >
     <h2>Compiler und Syntax</h2>
     <h4>Operatoren von CoffeeScript</h4>
     <table class="">
        <thead>
            <tr>
                <th>JavaScript</th>
                <th>CoffeeScript</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>===</td>
                <td>==, is</td>                
            </tr>
            <tr>
                <td>!==</td>
                <td>!=, isnt</td>                
            </tr>
             <tr>
                <td>&&, ||</td>
                <td>and, or</td>                
            </tr>
             <tr>
                <td>true</td>
                <td>yes, on</td>                
            </tr>
             <tr>
                <td>false</td>
                <td>no, off</td>                
            </tr>
        </tbody>
     </table>
<aside class="notes">
<ul>
<li> CoffeeScript hat Operatoren vereinfacht und aliase eingefügt (is). === wird automatisiert eingefügt. in cs nur == oder is nötig.</li>
<li>aliase ermöglichen boolsche ausdrücke als "text" zu verfassen</li>
</ul></aside>
</section>

<section class="msi-slides" >
     <h2>Compiler und Syntax</h2>
     <h4>CoffeeScript Features</h4>
     <ul>
         <li>Fat Arrow (=>) bindet <i>this</i> automatisch zu einer Funktion</li>
         <li>Comprehensions</li>
          <li>Klassen</li>
     </ul>
     <aside class="notes">
<ul>
<li>Die wichtigsten features: fat arrow (nimmt einem das binden ab) </li>
<li>Comprehensions: in js oft iteriert: Die meisten Schleifen in JavaScript beispielsweise über Arrays, Objekte können in CoffeeScript über Comprehensions geschrieben werden</li>
<li>Klassen vereinfachen typerweiterungen in js. verbergen die prototype chain für den programmierer.</li>
<li> klassen schauen wir uns jetzt im detail genauer an</li>
</ul></aside>
</section>
